[ { "title": "Fix WSL2 clock skew issues", "url": "/posts/wsl-tnt-fix-clock-skew/", "categories": "Tips & Tricks, WSL", "tags": "wsl, workaround, clockskew", "date": "2022-06-06 12:00:00 -0700", "snippet": "If you’re using WSL2 on a laptop, there are known issues with clock skew that can happen when your laptop hibernates. This can result in your WSL time and your Windows time getting out of sync and causes all kinds of issues inside Linux.To resolve this there are two workarounds: From inside WSL you can run the following command to re-sync with the hardware clock. $ hwclock -s Or from Windows you can just shutdown the WSL subsystem and it will automatically sync when it starts up the next time you use it. C:&amp;gt; wsl --shutdown Generally, I prefer #2 since it will be applied to all WSL environments in one go, and I can easily run it from Windows as part of my batch script that updates Linux in all my WSL environment. It does cause any existing WSL sessions to be terminated though, so if I’ve got a lot of sessions going I’ll just go for the first option." }, { "title": "Apply updates to multiple WSL Linux environments quickly", "url": "/posts/wsl-tnt-update-wsl-linux-env/", "categories": "Tips & Tricks, WSL", "tags": "wsl, apt", "date": "2022-06-05 12:00:00 -0700", "snippet": "You can update your default WSL environment with this command (assuming it uses the APT packaging system ):C:&amp;gt; wsl -u root -- bash -c &quot;apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremove&quot;If you have multiple, you can specify it on the command line with the Distro (-d) parameter. In the example below I’m updating 3 of my WSL environments in one go from a batch file.wsl -u root -d Ubuntu -- bash -c &quot;apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremove&quot;wsl -u root -d Debian -- bash -c &quot;apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremove&quot;wsl -u root -d kali-linux -- bash -c &quot;apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremove&quot;From here you could choose to run this batch file manually as needed, or automatically with the Windows scheduler.I find this approach makes it nice and easy to quickly keep all your WSL environments updated.A note about escaping special characters…You may be wondering why I’m calling bash when any command passed to WSL would have been executed by the bash shell anyway. I’m doing this to allow me to pass the command in double-quotes (“) to avoid having to escape any characters that are special to the Windows command shell.For example, if I just tried the following it would result in an error since Windows would interpret the &amp;amp;&amp;amp; and then try to run apt-get on the Windows side:wsl -u root -- apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremoveIn the above version, you will have to escape any special windows characters such as pipes | and conditionals &amp;amp;&amp;amp; to avoid them being handled by the Windows shell instead.wsl -u root -- apt-get update ^&amp;amp;^&amp;amp; apt-get -y upgrade ^&amp;amp;^&amp;amp; apt-get autoremoveThis option is perfectly fine, however I’d prefer to not have to think about which characters I have to escape for Windows vs. WSL, and just write my WSL command more naturally.We can workaround that by running bash explicitly and passing our command in a quoted string.wsl -u root -- bash -c &quot;apt-get update &amp;amp;&amp;amp; apt-get -y upgrade &amp;amp;&amp;amp; apt-get autoremove&quot;" }, { "title": "Use VS Code with the AVR toolchain", "url": "/posts/use-vscode-with-avr-toolchain/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, vscode", "date": "2022-05-21 11:00:00 -0700", "snippet": "OverviewThis guide will take you through the steps to configure Visual Studio Code for AVR programming in C/C++, including working Intellisense and a build task to execute your Makefile with different targets.PrerequisitesSetup AVR toolchainIf you haven’t already done so, start by setting up the AVR tool chain on your system so you can build AVR projects.Follow the appropriate guide for your platform: Windows-based AVR toolchain WSL-based AVR toolchain Linux-based toolchainWhile you’re at it you might as well head over and set up a Makefile to build your project now too as we’ll need that later when we set up the build task: Building AVR projects with makeInstall Visual Studio CodeDownload and install Visual Studio CodeInstall C/C++ extension packInstall the C/C++ extension packReview Visual Studio Code C/C++ documentationIf you’re not familiar with using VS Code with C/C++ on your chosen platform (Windows, WSL, Linux) I encourage you read through the VS Code documentation first before continuing.Basic configuration Using C++ on Linux in VS Code Using C++ and WSL in VS Code Using GCC with MinGW (I use gnuwin32 instead of MingGW)Cross-compiling (which is what we’re doing with AVR) IntelliSense for cross-compilingOpen the sample projectStart by opening the folder for your AVR project in VS Code. I’m going to use the blinker sample created in previous tutorials which consists of a folder named blinker, a single .c file named blink.c, and a Makefile. If you don’t already have a known working project to use, I suggestEdit C/C++ configurationOpen the Command Palette (Ctrl+Shift+P)Search for and run C/C++: Edit Configurations (JSON).This will create a new c_cpp_properties.json file in the .vscode/ directory of your project and open it for editing.You will need to make the following changes (see platform specific settings below): compilerPath: Update to avr-gcc (see platform specific settings below) &quot;-mmcu=atmega328p&quot; Will ensure MCU defines are set correctly &quot;-DF_CPU=16000000UL&quot; Will ensure F_CPU is set correctly &quot;-Os&quot; Will avoid optimization warnings re: _delay intelliSenseMode: Update to {os}-gcc-{arch} (“windows-gcc-x64” or “linux-gcc-x64” most likely) compilerArgs: Add any compiler arguments you use such as the mcu, F_CPU define, and optimization (-Os). These are necessary for the compiler and VS Code to work together to produce the right set of macros #defines for your MCU. includePath: No need to specify the AVR include paths as they will be included automatically. From the VS Code documentation:“You only need to modify the Include path if your program includes header files that aren’t in your workspace, or that are not in the standard library path. The C/C++ extension populates the include path by querying the compiler specified by Compiler path. If the extension can’t find the path for the target system libraries, you can enter the include path manually”On WSL / Linux: Change “intelliSenseMode” to “linux-gcc-x64” Update the compilerPath to “/usr/bin/avr-gcc” Include path: (Only if necessary) e.g. /usr/lib/avr/include/ You can find the path by running the command: dpkg -L avr-libc | grep avr/io.h On Windows: Change “intelliSenseMode” to “windows-gcc-x64” Update the compilerPath to avr-gcc.exe e.g. C:\\AVR\\avr8-gnu-toolchain\\bin\\avr-gcc.exe Include path: (Only if necessary) This is under the avr8-gnu-toolchain directory we created in the install e.g. C:\\AVR\\avr8-gnu-toolchain\\avr\\include\\ When you’re done it should like one of these examples below (depending on your platform).On Linux:{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/avr-gcc&quot;, &quot;cStandard&quot;: &quot;gnu11&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot;, &quot;compilerArgs&quot;: [ &quot;-mmcu=atmega328p&quot;, // Will ensure MCU defines are set correctly &quot;-DF_CPU=16000000UL&quot;, // Will ensure F_CPU is set correctly &quot;-Os&quot; // Will avoid optimization warnings re: _delay ] } ], &quot;version&quot;: 4}On Windows:{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;C:/AVR/avr8-gnu-toolchain/bin/avr-gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu11&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;, &quot;compilerArgs&quot;: [ &quot;-mmcu=atmega328p&quot;, // Will ensure MCU defines are set correctly &quot;-DF_CPU=16000000UL&quot;, // Will ensure F_CPU is set correctly &quot;-Os&quot; // Will avoid optimization warnings re: _delay ] } ], &quot;version&quot;: 4}Now that the above configration has been completed, your Intellisense should be working and you could use the built-in gcc build tasks via Run Build Task… (Ctrl+Shift+B) to run a simple build, but we’re going to use a Makefile. If you don’t have a Makefile for your project, you can create one in Building AVR projects with make.In the next step we’ll configure VS Code to build the project using your Makefile.Build tasksLet’s start by creating a tasks.json in our .vscode directory to define our new build task. While you can do this manually, we’re going to have VS Code generate the basic template for us. From the Terminal menu, select Configure Tasks…. Or search for Configure Task from the Command Palette (Ctrl+Shift+P) Choose Create tasks.json file from template Choose OthersSetting up a build task using make{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;make&quot;, &quot;detail&quot;: &quot;Run make&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;${input:makeTarget} &quot;, &quot;options&quot;: { &quot;env&quot;: { } }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot; } } ], &quot;inputs&quot;: [ { &quot;type&quot;: &quot;pickString&quot;, &quot;id&quot;: &quot;makeTarget&quot;, &quot;description&quot;: &quot;Select a build target&quot;, &quot;options&quot;: [ &quot;make all&quot;, &quot;sudo make flash&quot;, &quot;make disassemble&quot;, &quot;make squeaky_clean&quot;, &quot;make size&quot;, &quot;make debug&quot;, ], &quot;default&quot;: &quot;make all&quot; } ]}VariationsWindows but using WSL for makemake via WSL from Windowswsl make allUsing Windows-based tools that aren’taccess to windows maked tools&quot;Setting AVR build paths&quot;$toolpath = &quot;C:\\AVR&quot;$Env:PATH += &quot;;$toolpath\\avr8-gnu-toolchain\\bin&quot;$Env:PATH += &quot;;$toolpath\\avrdude&quot;Troubleshooting VS Code can’t find my AVR headers. First check that your AVR headers are installed. On Ubuntu Linux/WSL this is a separate package: avr-libc. Next check that you’ve specified the compilerPath and compilerArgs appropriately as VS Code finds the include paths by interrogating the compiler. VS Code STILL can’t find my AVR headers. Add the path to the AVR include paths manually. On Linux: e.g. /usr/lib/avr/include/ You can find the path by running the command: dpkg -L avr-libc | grep avr/io.h On Windows: This is under the avr8-gnu-toolchain directory we created in the install e.g. C:\\AVR\\avr8-gnu-toolchain\\avr\\include\\ It’s still not working Check out the VS Code FAQ for more help." }, { "title": "Building AVR projects with make", "url": "/posts/building-avr-projects-with-make/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, make", "date": "2022-05-21 11:00:00 -0700", "snippet": "In this guide we’ll go through the process of setting up a Makefile to build a simple AVR project.This guide assumes you have already set up a working AVR toolchain. If not please follow one of these guides first: How to setup the AVR toolchain on Windows How to setup the AVR toolchain on WSL2 (Windows 10+) How to setup the AVR toolchain on LinuxProject setupBefore we get into the Makefile, let’s setup a basic project consisting of a sample AVR program, blink.c, in a new directory. This basic program will blink an LED on and off every 500ms. Create a new directory named blinker to hold your project. It doesn’t matter what it’s named, but name it blinker so your your output matches the tutorial. Create a new file named blink.c, and with the following contents: #include &amp;lt;avr/io.h&amp;gt; #include &amp;lt;util/delay.h&amp;gt; int main() { // Set built-in LED pin as output DDRB |= (1 &amp;lt;&amp;lt; DDB5); while (1) { PORTB |= (1 &amp;lt;&amp;lt; PB5); // LED on _delay_ms(500); // wait 500ms PORTB &amp;amp;= ~(1 &amp;lt;&amp;lt; PB5); // LED off _delay_ms(500); // wait 500ms } return 0; } Building it manuallyNow that we have the project set up, let’s try building it manually first to see what’s involved.$ avr-gcc blink.c -o blinker.elf -mmcu=atmega328p -DF_CPU=16000000UL -OsIf it was successful, you’ll now have an compiled binary file along with your original .c file. You can remove that file before we continue:$ rm blinker.elfSetting up a project MakefileWhile you can certainly build the project like we did above, it error prone and more work especially whenRather than starting from scratch, I recommend using this Makefile as a starting point. It was written by the author of the Make: AVR Programming book, and is a good place to get started. It only requires a few edits to adjust for your chip and programmer.In your source folder, run the following commands to download the latest version of the Makefile, and make a few adjustments to it avoid errors since we’re not using his full project template.# Download Makefilewget https://raw.githubusercontent.com/hexagon5un/AVR-Programming/master/setupProject/Makefile# Remove LIBDIR that we&#39;re not usingsed -i -e &#39;s/^\\(LIBDIR =.\\+\\)/\\#\\1 \\# Not used/&#39; -e &#39;s/ -I$(LIBDIR)//&#39; MakefileConfiguring the Makefile for your chip and programmerThe next commands will configure the Makefile for building and flashing programs for the Arduino dev board. If you’re using a different chip or programmer you’ll need to either adjust these commands or make the adjustments manually.# SETUP FOR ARDUINO# Use ATmega328p and 16MHz with arduino programmersed -i -e &#39;s/^MCU.*/MCU = atmega328p/&#39; -e &#39;s/^F_CPU.*/F_CPU = 16000000UL/&#39; Makefilesed -i -e &#39;s/^PROGRAMMER_TYPE.*/PROGRAMMER_TYPE = arduino/&#39; -e &#39;s/^PROGRAMMER_ARGS.*/PROGRAMMER_ARGS = -P \\/dev\\/ttyACM0/&#39; MakefileIf you’re adjusting the Makefile manually, these lines at the top of the file are the ones you need to edit. I’ll explain them each briefly below:##########------------------------------------------------------#################### Project-specific Details #################### Check these every time you start a new project ####################------------------------------------------------------##########MCU = atmega328pF_CPU = 16000000UL BAUD = 9600UL## Also try BAUD = 19200 or 38400 if you&#39;re feeling lucky.## A directory for common include files and the simple USART library.## If you move either the current folder or the Library folder, you&#39;ll ## need to change this path to match.#LIBDIR = ../../AVR-Programming-Library##########------------------------------------------------------#################### Programmer Defaults #################### Set up once, then forget about it #################### (Can override. See bottom of file.) ####################------------------------------------------------------##########PROGRAMMER_TYPE = arduino# extra arguments to avrdude: baud rate, chip type, -F flag, etc.PROGRAMMER_ARGS = -P /dev/ttyACM0 MCU Defines what MicroController Unit (MCU) you are using. This variable is passed to both GCC and avrdude. For example, atmega328p is the MCU on an Arduino board. The complete list of options can be found in the GCC documentation. In addition to providing the compiler with instruction set and hardware details, this also sets up the appropriate #define values that control the AVR libary’s header definitions for pins, ports, etc. F_CPU Define the clock frequency of the MCU in Hz. Used by GCC. This value needs to match the fuse settings on your AVR chip. If not your program’s timing will not be correct. We’re using 16 MHz (16,000,000 Hz) for the Arduino. BAUD The baud rate for serial operations both by GCC for your program and avrdude for communication via serial programmers (if used in the PROGRAMMER_ARGS). PROGRAMMER_TYPE Type of programmer you are using (e.g. arduino, usbasp, etc.). Used by avrdude to communicate with your chip. We are using arduino for the Arduino dev board. PROGRAMMER_ARGS Additional arguments for avrdude. Some programmers require additional arguments such as the serial port to use. For example, when using arduino as the PROGRAMMER_TYPE we need to specify the serial port here (e.g. -P /dev/ttyACM0). Configuration examples Example 1. Settings for building with the Arduino board: MCU = atmega328pF_CPU = 16000000UL PROGRAMMER_TYPE = arduinoPROGRAMMER_ARGS = -P /dev/ttyACM0 Example 2. Settings for building with the ATtiny85 and USBasp programmer: MCU = attiny85F_CPU = 8000000UL PROGRAMMER_TYPE = usbaspPROGRAMMER_ARGS = Executing the MakefileOnce we have the Makefile configured appropriately, we can run it using the make or make all command. Both commands are equivalent for this Makefile as all is the first/default target defined in the Makefile. Running either of these commands will build your project and produce an Intel hex (.hex) file that ready to be flashed to your chip.$ make allThe next step is to flash the chip using make flash. When using make flash it isn’t necessary to run make all first since it will automatically execute the build step if anything has changed.You will need to make sure that your Arduino (or other programmer) is connected to the computer. You may need to run this command with sudo if your user doesn’t have the appropriate privileges to access the device. See Programming AVR in WSL Tips and Tricks to learn how to fix this.$ make flashAnother handy make target you can use is make clean or make squeaky_clean remove all the intermediate and final build output files.$ make squeaky_clean" }, { "title": "How to setup the AVR toolchain on WSL2 (Windows 10+)", "url": "/posts/setup-avr-toolchain-on-wsl/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, avrdude, avr-gcc", "date": "2022-05-21 10:00:00 -0700", "snippet": "OverviewThis guide will help you get your environment set up to build projects on the Atmel AVR chips (e.g. ATmega328, ATtiny85, etc.) projects on Windows using WSL-based tools.Summary: Install the AVR tools Testing the AVR toolchain Programming the chip Next Steps Troubleshooting Tutorial Versions I have written 3 different versions of this tutorial that cover the following different setups: Windows-based AVR toolchain This options primarily uses Windows-based tools and has two variations depending on how you run make Windows + GnuWin32 Windows + WSL WSL-based toolchain (this guide) This options primarily uses WSL-based linux tools and has two variations depending on how you program the chip – either WSL-based avrdude using usbip to access the USB programmer or Windows-based avrdude to natively access the USB programmer WSL + usbip WSL + Windows Linux-based toolchain This option uses all native linux-based tools on a native Linux installation. You can see a summary of how the versions differ in the table below: Version avr toolchain make avrdude usb access Windows+GnuWin32 windows gnuwin32 windows - Windows+WSL windows WSL windows - WSL+usbip WSL WSL WSL usbip WSL+Windows WSL WSL windows - Linux linux linux linux - Install the AVR toolsAll the packages we need are already available in Ubuntu. Depending on your distribution release, the tools may not be the latest, but should be fine in most cases. If you need the latest versions or need to do a manual install for some reason, follow this guide instead: How to manually install AVR tools on Linux (or WSL2) Tool 20.04 Focal (LTS) 22.04 Jammy (LTS) avr-gcc 3.6.1 3.6.2 avrdude 6.3 6.3 We can install all the tools we need in a single command.$ sudo apt install make gcc-avr avr-libc avrdudeLet’s run a quick check that all the tools are installed before we continue by running following commands:make -vavr-gcc --versionavrdude -vThe output should look something like this:$ make -vGNU Make 4.2.1Built for x86_64-pc-linux-gnuCopyright (C) 1988-2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.$ avr-gcc --versionavr-gcc (GCC) 5.4.0Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ avrdude -vavrdude: Version 6.3-20171130 Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/ Copyright (c) 2007-2014 Joerg Wunsch System wide configuration file is &quot;/etc/avrdude.conf&quot; User configuration file is &quot;/home/tony/.avrduderc&quot; User configuration file does not exist or is not a regular file, skippingavrdude: no programmer has been specified on the command line or the config file Specify a programmer using the -c option and try againIf any of those produced an error or could not be found, you’ll need to re-visit the installation steps before continuing.Testing the AVR toolchainTo test that everything is working correctly, let’s try building a sample program and writing it to an Arduino. If you don’t have an Arduino handy, you can either skip the avrdude step or adjust the program and commands to fit your scenario.In a new directory, create a new file named blink.c and paste the following program into it. This is a AVR implementation of the classic Arduino Blink sketch. If you load this to an Arduino it will make the built-in LED (pin 13/LED_BUILTIN) flash on and off every 500ms.#include &amp;lt;avr/io.h&amp;gt;#include &amp;lt;util/delay.h&amp;gt;int main(){ // Set built-in LED pin as output DDRB |= (1 &amp;lt;&amp;lt; DDB5); while (1) { PORTB |= (1 &amp;lt;&amp;lt; PB5); // LED on _delay_ms(500); PORTB &amp;amp;= ~(1 &amp;lt;&amp;lt; PB5); // LED off _delay_ms(500); } return 0;}In the directory you created the file, run the following commands. Make sure you plug in your Arduino before running avrdude and update the COM port to match the one assigned to your Arduino.avr-gcc blink.c -o blink.elf -mmcu=atmega328 -DF_CPU=16000000UL -Osavr-objcopy blink.elf -O ihex blink.hexIf everything is working you should see something like.$ avr-gcc blink.c -o blink.elf -mmcu=atmega328 -DF_CPU=16000000UL -Os$ avr-objcopy blink.elf -O ihex blink.hexProgramming the chipAt the time of writing WSL2 cannot directly interact with serial devices such as Arduinos or USB programmers.I’ve documented two workarounds: Option 1: Using USB/IP - Use USB/IP to capture and expose the device in WSL. Option 2: Using avrdude.exe (Windows-based) - Use a Windows version of avrdude to program the chip since it can directly access the device.These choices don’t conflict with each other so you can always do both and see which you prefer.Option 1: Using USB/IPRecent versions of Windows and WSL2 have support for accessing host USB devices using usbipd-win.InstallTo install, follow the instructions at (or see below for a shorter version): https://devblogs.microsoft.com/commandline/connecting-usb-devices-to-wsl/ If you run into issues, you may need to build a custom kernel for WSL which is covered in this guide. So far it hasn’t been necessary for me.: https://github.com/dorssel/usbipd-win/wiki/WSL-support For convenience, I have summarized the steps below (see original guide for more information): In WSL, run the following commands: sudo apt install linux-tools-5.4.0-77-generic hwdata sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/5.4.0-77-generic/usbip 20 In Windows Command Prompt (as Admin), run the following command: winget install --interactive --exact dorssel.usbipd-win NOTE: After you’ve run it at least once as an Administrator in Windows, you can run it as a normal user in the future. You can even run it from WSL. Notice how I’ve used the full filename including the extension (.exe) to tell windows we’re running the windows executable):usbipd.exe wsl attach --hardware-id=2341:0001TestTo test the usbip setup, do the following: Plug in a USB device to the Windows host List the USB devices available: usbipd wsl list You should see your device listed. Note the bus ID (e.g 5-7) Attach the device to WSL (update busid value with the value for your device): usbipd wsl attach --busid=5-7 In WSL, list the available usb devices: lsusb You should see your device in list.Example 1: Arduino UnoOpen an Administrative Command Prompt in Windows and attach the device to wsl using the commands below.C:\\&amp;gt;usbipd wsl attach --hardware-id=2341:0001usbipd: info: Device with hardware-id &#39;2341:0001&#39; found at busid &#39;5-7&#39;.usbipd: info: Using default distribution &#39;Ubuntu&#39;.In this example, I’m attaching an Arduino Uno based on it’s hardware ID. This value is fixed for a specific device. If you expect to have more than one of the same device attached at the same time, you’ll need to use bus ID instead. For single device usage, hardware ID is more portable when you’re using it for a specific device/programmerRunning lsusb and passing the same hardware ID should show the device is now available in WSL$ lsusb -d 2341:0001Bus 001 Device 002: ID 2341:0001 Arduino SA Uno (CDC ACM)The Arduno Uno has attached itself as a CDC/ACM device, and so should be available via a /dev/ttyACM* device.Running avrdude will require passing the appropriate ttyACM device path such as in the example below:sudo avrdude -c arduino -p m328p -U flash:w:&quot;blink.hex&quot;:a -P /dev/ttyACM0Example 2: USBaspHere is another example using a USBasp clone.In Windows Command Prompt (as Admin), run the following command:C:\\&amp;gt;usbipd wsl attach --hardware-id=16c0:05dcusbipd: info: Device with hardware-id &#39;16c0:05dc&#39; found at busid &#39;5-7&#39;.usbipd: info: Using default distribution &#39;Ubuntu&#39;.In WSL, run the following command:$ lsusb -d 16c0:05dcBus 001 Device 003: ID 16c0:05dc Van Ooijen Technische Informatica shared ID for use with libusbThen in WSL run avrdude against that device. Notice we don’t have to specify a port (-P) with usbasp:sudo avrdude -c usbasp -p m328p -U flash:w:&quot;blink.hex&quot;:aUnless you’re planning on using both options, you can skip ahead to Next Steps. Why do I need to use sudo with avrdude? Normally in Ubuntu linux, when you plug in a device it run udev rules that setup the necessary device paths and the appropriate permissions. Unfortunately in WSL2 that doesn’t work fully because systemd isn’t running. There are some workarounds that you can use to get this mostly working and you can read more about that in my other post, Programming AVR in WSL Tips and Tricks. Otherwise, you will need to run avrdude as root via sudo to gain access to the device.Option 2: Using avrdude.exe (Windows-based)This approach should work in most versions of Windows. Install the Windows version of avrdude. See “Install AVR Dude” section of Windows-based tutorial. Ensure avrdude.exe is on the PATH.You can run avrdude from either Windows command prompt, or WSL, but if calling from WSL you need to include the full executable name including the extension – avrdude.exe – such as:$ /mnt/c/AVR/avrdude/avrdude.exe -c arduino -p m328p -U flash:w:&quot;blink.hex&quot;:a -P COM4avrdude.exe: AVR device initialized and ready to accept instructionsReading | ################################################## | 100% 0.00savrdude.exe: Device signature = 0x1e950f (probably m328p)avrdude.exe: NOTE: &quot;flash&quot; memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option.avrdude.exe: erasing chipavrdude.exe: reading input file &quot;blink.hex&quot;avrdude.exe: input file blink.hex auto detected as Intel Hexavrdude.exe: writing flash (176 bytes):Writing | ################################################## | 100% 0.04savrdude.exe: 176 bytes of flash writtenavrdude.exe: verifying flash memory against blink.hex:avrdude.exe: input file blink.hex auto detected as Intel HexReading | ################################################## | 100% 0.03savrdude.exe: 176 bytes of flash verifiedavrdude.exe done. Thank you.NOTE: Since you are calling the Windows version you should use the Windows method of identifying serial ports (e.g. COM4).Next StepsThat’s all there is to it. To continue setting up your development environment check out my other posts on building projects with a Makefile and configuring VS Code: Building AVR projects with make Use VS Code with the AVR toolchainTroubleshooting How do I find out what COM port my Arduino is using? Open Device Manager. Expand Ports (COM &amp;amp; LPT). You should see an entry named something like “Arduino Uno (COM4)”. The COM port is in parentheses." }, { "title": "How to setup the AVR toolchain on Windows", "url": "/posts/setup-avr-toolchain-on-windows/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, avrdude, avr-gcc", "date": "2022-05-21 10:00:00 -0700", "snippet": "OverviewThis guide will help you get your environment set up to build projects on the Atmel AVR chips (e.g. ATmega328, ATtiny85, etc.) projects on Windows using Windows-based tools.Summary: Prep Install AVR toolchain (to build the code) Install AVR Dude (to flash the chip) Install GnuWin32 (for supporting build tools like Make) Configure PATH (to make tools available) Testing the AVR toolchain Next Steps Troubleshooting Tutorial Versions I have written 3 different versions of this tutorial that cover the following different setups: Windows-based AVR toolchain (this guide) This options primarily uses Windows-based tools and has two variations depending on how you run make Windows + GnuWin32 Windows + WSL WSL-based AVR toolchain This options primarily uses WSL-based linux tools and has two variations depending on how you program the chip – either WSL-based avrdude using usbip to access the USB programmer or Windows-based avrdude to natively access the USB programmer WSL + usbip WSL + Windows Linux-based AVR toolchain This option uses all native linux-based tools on a native Linux installation. You can see a summary of how the versions differ in the table below: Version avr toolchain make avrdude usb access Windows+GnuWin32 windows gnuwin32 windows - Windows+WSL windows WSL windows - WSL+usbip WSL WSL WSL usbip WSL+Windows WSL WSL windows - Linux linux linux linux - PrepStart by creating a folder to hold all your dev tools (e.g. C:\\Tools\\AVR or C:\\Users&amp;lt;user&amp;gt;\\AVR). I will be using C:\\AVR in this guide.Install AVR toolchainDownloadThe first step is to download the AVR toolchain from the Microchip website. The toolchain can be downloaded as part of the Atmel Studio IDE or standalone. For this guide we will use the standalone toolchain and use VS Code as the IDE. Browse to toolchain download page at: https://www.microchip.com/en-us/tools-resources/develop/microchip-studio/gcc-compilers From the downloads list, find and download the appropriate toolchain for your chip and dev OS. For this guide we will download the toolchain for AVR 8-bit chips (like ATmega328 or ATtiny) that runs on Windows. At the time of writing that was AVR 8-bit Toolchain v3.62 – Windows. NOTE: You will have to sign up for a free account to complete the download At the time of writing the main download page wasn’t working, so alternatively you can download the prior version (3.6.1) release from the archives at: https://www.microchip.com/en-us/tools-resources/archives/avr-sam-mcus#AVR and Arm-Based MCU Toolchains I also recommend downloading the Release Notes for your toolchain (if any). They should be available on the same downloads page. (e.g. AVR 8-bit Toolchain 3.6.1 - Release Note). The release notes can contain important installation instructions (like the fact that you may need to download chip packs) [Optional] IF the chip you are using isn’t supported out-of-the-box by the main toolchain, browse to: http://packs.download.atmel.com/ to find and download the appropriate chip packs. Note: most of the popular chips should already be supported). Even if you don’t NEED the chip packs, there is additional documentation in them that you might find valuable to read. The chip pack files end in .atpack, but are actually .zip archive files and needs to be expanded to be used. If you need to use a chip pack, you will need to reference the directory via -B and -I options when compiling. For example: avr-gcc -mmcu=atmega328pb -B /home/packs/Atmel.ATmega_DFP.1.0.86/gcc/dev/atmega328pb/ -I /home/packs/Atmel.ATmega_DFP.1.0.86/include/ InstallUnzip the downloaded toolchain archive (e.g. avr8-gnu-toolchain-3.6.1.1752-win32.any.x86.zip) into the tools folder you created earlier. You should now have a directory named avr8-gnu-toolchain-win32_x86 in your tools folder. My preference is to rename the directory to remove any platform specific names (e.g. win32_x86) to make any scripts I create platform agnostic and more portable (e.g. avr8-gnu-toolchain).Tools directory so far:C:\\AVR└───avr8-gnu-toolchain ├───avr ├───bin ├───doc └───...[Optional] If you choose to download the chi ppacks as well, I recommend unzipping those into a separate directory for chip packs with each chip pack in a separate subfolder.Tools directory so far:C:\\AVR├───avr-device-packs│ ├───Atmel.ATmega_DFP.2.0.401│ │ ├───gcc│ │ ├───include│ │ └───...│ └───Atmel.ATtiny_DFP.2.0.368└───avr8-gnu-toolchainTestTo test the installation of the avr-gcc toolchain, run avr-gcc --version in the avr8-gnu-toolchain\\bin directory. The output should look something this:C:\\AVR\\avr8-gnu-toolchain\\bin&amp;gt;avr-gcc --versionavr-gcc (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Install AVR DudeDownload Browse to the AVR Dude releases directory on GitHub: https://github.com/avrdudes/avrdude/releases Download the latest version for your OS (e.g. avrdude-v7.0-windows-x86.zip). If you’re looking for older versions such as v6.4 or prior, they are can be found at their old site: http://download.savannah.gnu.org/releases/avrdude/ (e.g avrdude-6.4-mingw32.zip)InstallUnzip the downloaded archive (e.g. avrdude-v7.0-windows-x86.zip) into the tools folder into a directory named “avrdude”. This will keep it version and platform agnostic.Tools directory so far:C:\\AVR├───avr8-gnu-toolchain└───avrdude ├───avrdude.exe └───... TestTo test the installation of avrdude, run avrdude in the avrdude directory. The output should look something this:C:\\DEV\\AVR\\avrdude&amp;gt;avrdude.exeUsage: avrdude.exe [options]Options: -p &amp;lt;partno&amp;gt; Required. Specify AVR device. -b &amp;lt;baudrate&amp;gt; Override RS-232 baud rate. -B &amp;lt;bitclock&amp;gt; Specify JTAG/STK500v2 bit clock period (us). -C &amp;lt;config-file&amp;gt; Specify location of configuration file. -c &amp;lt;programmer&amp;gt; Specify programmer type. -D Disable auto erase for flash memory -i &amp;lt;delay&amp;gt; ISP Clock Delay [in microseconds] -P &amp;lt;port&amp;gt; Specify connection port. -F Override invalid signature check. -e Perform a chip erase. -O Perform RC oscillator calibration (see AVR053). -U &amp;lt;memtype&amp;gt;:r|w|v:&amp;lt;filename&amp;gt;[:format] Memory operation specification. Multiple -U options are allowed, each request is performed in the order specified. -n Do not write anything to the device. -V Do not verify. -t Enter terminal mode. -E &amp;lt;exitspec&amp;gt;[,&amp;lt;exitspec&amp;gt;] List programmer exit specifications. -x &amp;lt;extended_param&amp;gt; Pass &amp;lt;extended_param&amp;gt; to programmer. -v Verbose output. -v -v for more. -q Quell progress output. -q -q for less. -l logfile Use logfile rather than stderr for diagnostics. -? Display this usage.avrdude version 7.0, URL: &amp;lt;https://github.com/avrdudes/avrdude&amp;gt;Install GnuWin32The GnuWin32 project provides ports of GNU tools to Windows. For our purposes, the main tool we’ll need from GnuWin32 is make. You can download and install just make, but my preferences is to download and install the full tool suite because there are lots of additional useful tools in there, and that’s what we’ll do in this guide.Download Browse to https://sourceforge.net/projects/getgnuwin32/files/getgnuwin32/0.6.30/ and download GetGnuWin32-0.6.3.exe. If for some reason that link doesn’t work, you can start back on the project site and navigate to the downloads folder from there. Save that file to a temporary location such as C:\\temp or your Downloads folder.Install Run the executable you downloaded (e.g GetGnuWin32-0.6.3.exe). When presented, Accept the licence. You will be presented with a summary of installation instructions which should align to the steps below. Click the Install button. This will create a new folder in the same location the executable was located (e.g. C:\\temp) Open a Command Prompt as Administrator to ensure the next steps have permission necessary to install. Change directory to the new folder created when you ran the installer. (e.g. C:\\temp\\GetGnuWin32) C:\\&amp;gt; cd \\temp\\GetGnuWin32 Run download.bat. This will download all the packages necessary for gnuwin32. You will be prompted to press a key a few times before downloads start. The downloads can take a while even with a fast internet connection. C:\\temp\\GetGnuWin32&amp;gt; download.bat If there any failed downloads, run the download.bat again until they are all successfull. Once all the packages have been downloaded successfully, run the install.bat and pass it the target directory where gnuwin32 should be installed. If your tools directory is C:\\AVR, then you would pass C:\\AVR\\gnuwin32 as in the example below. C:\\temp\\GetGnuWin32&amp;gt; install.bat C:\\AVR\\gnuwin32 You will be prompted about installing updated versions of several components. When prompted, just hit Enter to accept the default responses to install these updated components.Tools directory so far:C:\\AVR├───avr8-gnu-toolchain├───avrdude└───gnuwin32 ├───bin ├───contrib ├───doc └───... TestTo test the installation of gnuwin32, run make -v in the gnuwin32\\bin directory. The output should look something this:C:\\DEV\\gnuwin32\\bin\\&amp;gt;make -vGNU Make 3.81Copyright (C) 2006 Free Software Foundation, Inc.This is free software; see the source for copying conditions.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE.This program built for i386-pc-mingw32Configure PATHAt this point all the tools are installed, but we still need to make them available on the PATH. Since some of the GnuWin32 tools can conflict with built-in Windows tools of the same name, we’ll only add these tools to the PATH when we need them via a batch file.Here is a summary of what you’ve done so far: Zip Target Location Install avr8-gnu-toolchain-3.6.2.1778-win32.any.x86.zip C:\\AVR\\avr8-gnu-toolchain Unzip to target avrdude-v7.0-windows-x86.zip C:\\AVR\\avrdude Unzip to target GetGnuWin32-0.6.3.exe C:\\AVR\\gnuwin32 Installer, download.bat, install.bat C:\\AVR\\gnuwin32 Chip packs (*.atpack) C:\\AVR\\avr8-dvp Unzip to target We’ll create two separate batch files – one for setting the paths, and another for opening a command prompt with the paths set. This way if you want to just add the paths to an existing console session you can run the first, but if you want a brand new session you can run the second.Create a new file in your tools directory named set_avr_paths.cmd, and paste in the following:@ECHO OFFECHO Setting AVR tool pathsSET TOOLS_DIR=C:\\AVRSET PATH=%PATH%;%TOOLS_DIR%\\avr8-gnu-toolchain\\binSET PATH=%PATH%;%TOOLS_DIR%\\avrdudeSET PATH=%PATH%;%TOOLS_DIR%\\gnuwin32\\binCreate another new file in your tools directory named avr_dev_prompt.cmd, and paste in the following:@TITLE AVR Dev Command Prompt@%comspec% /k &quot; cd \\ &amp;amp; &quot;%~dp0set_avr_paths.cmd&quot; &quot;Testing the AVR toolchainTo test that everything is working correctly, let’s try building a sample program and writing it to an Arduino. If you don’t have an Arduino handy, you can either skip the avrdude step or adjust the program and commands to fit your scenario.In a new directory, create a new file named blink.c and paste the following program into it. This is a AVR implementation of the classic Arduino Blink sketch. If you load this to an Arduino it will make the built-in LED (pin 13/LED_BUILTIN) flash on and off every 500ms.#include &amp;lt;avr/io.h&amp;gt;#include &amp;lt;util/delay.h&amp;gt;int main(){ // Set built-in LED pin as output DDRB |= (1 &amp;lt;&amp;lt; DDB5); while (1) { PORTB |= (1 &amp;lt;&amp;lt; PB5); // LED on _delay_ms(500); PORTB &amp;amp;= ~(1 &amp;lt;&amp;lt; PB5); // LED off _delay_ms(500); } return 0;}Double-click the avr_dev_prompt.cmd batch file you created above to prepare a console session with tools on the PATH.In the directory you created the file, run the following commands. Make sure you plug in your Arduino before running avrdude and update the COM port to match the one assigned to your Arduino.avr-gcc blink.c -o blink.elf -mmcu=atmega328 -DF_CPU=16000000UL -Osavr-objcopy blink.elf -O ihex blink.hexavrdude -c arduino -p atmega328p -U flash:w:&quot;blink.hex&quot;:a -P COM4If everything is working you should see something like.C:\\temp\\blink&amp;gt;avr-gcc blink.c -o blink.elf -mmcu=atmega328p -DF_CPU=16000000UL -OsC:\\temp\\blink&amp;gt;avr-objcopy blink.elf -O ihex blink.hexC:\\temp\\blink&amp;gt;avrdude -c arduino -p atmega328p -U flash:w:&quot;blink.hex&quot;:a -P COM4avrdude: AVR device initialized and ready to accept instructionsReading | ################################################## | 100% 0.00savrdude: Device signature = 0x1e950f (probably m328p)avrdude: NOTE: &quot;flash&quot; memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option.avrdude: erasing chipavrdude: reading input file &quot;blink.hex&quot;avrdude: input file blink.hex auto detected as Intel Hexavrdude: writing flash (176 bytes):Writing | ################################################## | 100% 0.04savrdude: 176 bytes of flash writtenavrdude: verifying flash memory against blink.hex:avrdude: input file blink.hex auto detected as Intel HexReading | ################################################## | 100% 0.03savrdude: 176 bytes of flash verifiedavrdude done. Thank you.Next StepsThat’s all there is to it. To continue setting up your development environment check out my other posts on building projects with a Makefile and configuring VS Code: Building AVR projects with make Use VS Code with the AVR toolchainTroubleshooting How do I find out what COM port my Arduino is using? Open Device Manager. Expand Ports (COM &amp;amp; LPT). You should see an entry named something like “Arduino Uno (COM4)”. The COM port is in parentheses." }, { "title": "How to setup the AVR toolchain on Linux", "url": "/posts/setup-avr-toolchain-on-linux/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, avrdude, avr-gcc", "date": "2022-05-21 10:00:00 -0700", "snippet": "OverviewThis guide will help you get your environment set up to build projects on the Atmel AVR chips (e.g. ATmega328, ATtiny85, etc.) projects on Windows using Linux-based (Ubuntu) tools.Summary: Install the AVR tools Testing the AVR toolchain Next Steps Troubleshooting Tutorial Versions I have written 3 different versions of this tutorial that cover the following different setups: Windows-based AVR toolchain This options primarily uses Windows-based tools and has two variations depending on how you run make Windows + GnuWin32 Windows + WSL WSL-based AVR toolchain This options primarily uses WSL-based linux tools and has two variations depending on how you program the chip – either WSL-based avrdude using usbip to access the USB programmer or Windows-based avrdude to natively access the USB programmer WSL + usbip WSL + Windows Linux-based AVR toolchain (this guide) This option uses all native linux-based tools on a native Linux installation. You can see a summary of how the versions differ in the table below: Version avr toolchain make avrdude usb access Windows+GnuWin32 windows gnuwin32 windows - Windows+WSL windows WSL windows - WSL+usbip WSL WSL WSL usbip WSL+Windows WSL WSL windows - Linux linux linux linux - Install the AVR toolsAll the packages we need are already available in Ubuntu. Depending on your distribution release, the tools may not be the latest, but should be fine in most cases. If you need the latest versions or need to do a manual install for some reason, follow this guide instead: How to manually install AVR tools on Linux (or WSL2) Tool 20.04 Focal (LTS) 22.04 Jammy (LTS) avr-gcc 3.6.1 3.6.2 avrdude 6.3 6.3 We can install all the tools we need in a single command.$ sudo apt install make gcc-avr avr-libc avrdudeLet’s run a quick check that all the tools are installed before we continue by running following commands:make -vavr-gcc --versionavrdude -vThe output should look something like this:$ make -vGNU Make 4.2.1Built for x86_64-pc-linux-gnuCopyright (C) 1988-2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.$ avr-gcc --versionavr-gcc (GCC) 5.4.0Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ avrdude -vavrdude: Version 6.3-20171130 Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/ Copyright (c) 2007-2014 Joerg Wunsch System wide configuration file is &quot;/etc/avrdude.conf&quot; User configuration file is &quot;/home/tony/.avrduderc&quot; User configuration file does not exist or is not a regular file, skippingavrdude: no programmer has been specified on the command line or the config file Specify a programmer using the -c option and try againIf any of those produced an error or could not be found, you’ll need to re-visit the installation steps before continuing.Testing the AVR toolchainTo test that everything is working correctly, let’s try building a sample program and writing it to an Arduino. If you don’t have an Arduino handy, you can either skip the avrdude step or adjust the program and commands to fit your scenario.In a new directory, create a new file named blink.c and paste the following program into it. This is a AVR implementation of the classic Arduino Blink sketch. If you load this to an Arduino it will make the built-in LED (pin 13/LED_BUILTIN) flash on and off every 500ms.#include &amp;lt;avr/io.h&amp;gt;#include &amp;lt;util/delay.h&amp;gt;int main(){ // Set built-in LED pin as output DDRB |= (1 &amp;lt;&amp;lt; DDB5); while (1) { PORTB |= (1 &amp;lt;&amp;lt; PB5); // LED on _delay_ms(500); PORTB &amp;amp;= ~(1 &amp;lt;&amp;lt; PB5); // LED off _delay_ms(500); } return 0;}In the directory you created the file, run the following commands. Make sure you plug in your Arduino before running avrdude and update the device port to match the one assigned to your Arduino.avr-gcc blink.c -o blink.elf -mmcu=atmega328 -DF_CPU=16000000UL -Osavr-objcopy blink.elf -O ihex blink.hexavrdude -c arduino -p m328p -U flash:w:&quot;blink.hex&quot;:a -P /dev/ttyACM0If everything is working you should see something like.$ avr-gcc blink.c -o blink.elf -mmcu=atmega328 -DF_CPU=16000000UL -Os$ avr-objcopy blink.elf -O ihex blink.hex$ avrdude -c arduino -p m328p -U flash:w:&quot;blink.hex&quot;:a -P /dev/ttyACM0avrdude: AVR device initialized and ready to accept instructionsReading | ################################################## | 100% 0.00savrdude: Device signature = 0x1e950f (probably m328p)avrdude: NOTE: &quot;flash&quot; memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option.avrdude: erasing chipavrdude: reading input file &quot;blink.hex&quot;avrdude: input file blink.hex auto detected as Intel Hexavrdude: writing flash (176 bytes):Writing | ################################################## | 100% 0.04savrdude: 176 bytes of flash writtenavrdude: verifying flash memory against blink.hex:avrdude: input file blink.hex auto detected as Intel HexReading | ################################################## | 100% 0.03savrdude: 176 bytes of flash verifiedavrdude done. Thank you.Next StepsThat’s all there is to it. To continue setting up your development environment check out my other posts on building projects with a Makefile and configuring VS Code: Building AVR projects with make Use VS Code with the AVR toolchainTroubleshooting How do I find out what port my Arduino is using? TBD - Easiest is dmesg / lsusb How do I run avrdude without sudo? TBD - udev rule / plugdev group" }, { "title": "How to manually install AVR tools on Linux (or WSL2)", "url": "/posts/manually-install-avr-tools-on-linux/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, avrdude, avr-gcc", "date": "2022-05-21 10:00:00 -0700", "snippet": "If you’re just looking to install the AVR tools on Linux or WSL please try one of these approaches first: How to setup the AVR toolchain on Linux How to setup the AVR toolchain on WSL2 (Windows 10+)If for some reason, the Ubuntu packaged versions don’t work for you, it is possible to manually install the latest versions of the tools. This post will guide you through that process. I don’t recommend this approach, but if you’re experiencing an issue with an older version and need the latest version you can follow some or all of these steps to install the latest version. NOTE: If you’re on a recent version of Ubuntu, avr-gcc tends to be up-to-date. It’s only avrdude that doesn’t include the latest version.PrepIn this option we will manually install the latest version of the tools into your home directory under ~/.local/. You may need to create it if it doesn’t already exist.$ mkdir ~/.localInstall AVR toolchainDownloadThe first step is to download the AVR toolchain from the Microchip website. The toolchain can be downloaded as part of the Atmel Studio IDE or standalone. For this guide we will use the standalone toolchain. Browse to toolchain download page at: https://www.microchip.com/en-us/tools-resources/develop/microchip-studio/gcc-compilers From the downloads list, find and download the appropriate toolchain for your chip and dev OS. For this guide we will download the toolchain for AVR 8-bit chips (like ATmega328 or ATtiny) that runs on Linux 64-bit since WSL is a 64-bit Linux. At the time of writing that was AVR 8-bit Toolchain 3.6.2 - Linux 64-bit. NOTE: You will have to sign up for a free account to complete the download At the time of writing the main download page wasn’t working, so alternatively you can download the prior version (AVR 8-bit Toolchain 3.6.1 - Linux 64-bit) release from the archives at: https://www.microchip.com/en-us/tools-resources/archives/avr-sam-mcus#AVR and Arm-Based MCU Toolchains I also recommend downloading the Release Notes for your toolchain (if any). They should be available on the same downloads page. (e.g. AVR 8-bit Toolchain 3.6.1 - Release Note). The release notes can contain important installation instructions (like the fact that you may need to download chip packs) [Optional] IF the chip you are using isn’t supported out-of-the-box by the main toolchain, browse to: http://packs.download.atmel.com/ to find and download the appropriate chip packs. Note: most of the popular chips should already be supported). Even if you don’t NEED the chip packs, there is additional documentation in them that you might find valuable to read. The chip pack files end in .atpack, but are actually .zip archive files and needs to be expanded to be used. If you need to use a chip pack, you will need to reference the directory via -B and -I options when compiling. For example: avr-gcc -mmcu=atmega328pb -B ~/avr-device-packs/Atmel.ATmega_DFP.1.0.86/gcc/dev/atmega328pb/ -I ~/avr-device-packs/Atmel.ATmega_DFP.1.0.86/include/ InstallUnzip the downloaded toolchain archive (e.g. avr8-gnu-toolchain-3.6.1.1752-linux.any.x86_64.tar.gz) in your home directory. You should now have a directory named avr8-gnu-toolchain-linux_x86_64 in your home directory. The contents of this folder need to be copied to your ~/.local/ folder.cdtar xvzf avr8-gnu-toolchain-3.6.1.1752-linux.any.x86_64.tar.gzcp -a ~/avr8-gnu-toolchain-linux_x86_64/* ~/.local/Our additions to the home directory so far:~/└───.local ├───avr ├───bin ├───doc └───...[Optional] If you choose to download the chi ppacks as well, I recommend unzipping those into a separate directory for chip packs (e.g. ~/avr-device-packs) with each chip pack in a separate subfolder (~/avr-device-packs/Atmel.ATmega_DFP.2.0.401/).Our additions to the home directory so far:~/├───avr-device-packs│ ├───Atmel.ATmega_DFP.2.0.401│ │ ├───gcc│ │ ├───include│ │ └───...│ └───Atmel.ATtiny_DFP.2.0.368└───.localTestTo test the installation of the avr-gcc toolchain, run avr-gcc --version in the ~/.local/bin directory. The output should look something this:~/.local/bin$ ./avr-gcc --versionavr-gcc (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Install AVR DudeDownload Browse to the AVR Dude releases directory on GitHub: https://github.com/avrdudes/avrdude/releases Download the latest version for your OS (e.g. avrdude-7.0.tar.gz) to your home directory. If you’re looking for older versions such as v6.4 or prior, they are can be found at their old site: http://download.savannah.gnu.org/releases/avrdude/ (e.g avrdude-6.4.tar.gz)# Download releasewget https://github.com/avrdudes/avrdude/releases/download/v7.0/avrdude-7.0.tar.gzInstallThis will install avrdude into your $HOME/.local structure. You can update the configure command if you wish to install it elsewhere.# Expand archivetar xvzf avrdude-7.0.tar.gzcd avrdude-7.0/# Build avrdude (See https://www.nongnu.org/avrdude/user-manual/avrdude_18.html#Unix)./configure --prefix=$HOME/.localmakemake installTestTo test the installation of avrdude, run avrdude in the .local/bin directory. The output should look something this:~/.local/bin$ ./avrdudeUsage: avrdude [options]Options: -p &amp;lt;partno&amp;gt; Required. Specify AVR device. -b &amp;lt;baudrate&amp;gt; Override RS-232 baud rate. -B &amp;lt;bitclock&amp;gt; Specify JTAG/STK500v2 bit clock period (us). -C &amp;lt;config-file&amp;gt; Specify location of configuration file. -c &amp;lt;programmer&amp;gt; Specify programmer type. -D Disable auto erase for flash memory -i &amp;lt;delay&amp;gt; ISP Clock Delay [in microseconds] -P &amp;lt;port&amp;gt; Specify connection port. -F Override invalid signature check. -e Perform a chip erase. -O Perform RC oscillator calibration (see AVR053). -U &amp;lt;memtype&amp;gt;:r|w|v:&amp;lt;filename&amp;gt;[:format] Memory operation specification. Multiple -U options are allowed, each request is performed in the order specified. -n Do not write anything to the device. -V Do not verify. -t Enter terminal mode. -E &amp;lt;exitspec&amp;gt;[,&amp;lt;exitspec&amp;gt;] List programmer exit specifications. -x &amp;lt;extended_param&amp;gt; Pass &amp;lt;extended_param&amp;gt; to programmer. -v Verbose output. -v -v for more. -q Quell progress output. -q -q for less. -l logfile Use logfile rather than stderr for diagnostics. -? Display this usage.avrdude version 7.0, URL: &amp;lt;https://github.com/avrdudes/avrdude&amp;gt;Configure PATHAt this point all the tools are installed, but we still need to make them available on the PATH. Since some of the GnuWin32 tools can conflict with built-in Windows tools of the same name, we’ll only add these tools to the PATH when we need them via a batch file.Here is a summary of what you’ve done so far: Zip Target Location Install avr8-gnu-toolchain-3.6.2.1778-win32.any.x86.zip ~/.local/ Unzip to target avrdude-v7.0-windows-x86.zip ~/.local/ Build and install to target Chip packs (*.atpack) ~/avr-device-packs/ Unzip to target In many distributions of linux, including the WSL default Ubuntu, the .local/bin directory will be added to your path automatically and we won’t have to do anything else except log out and log back in. Log out and back in, and then try running avr-gcc --version and avrdude -v to see if they’re now in your path.If so, you’re all done. If not, edit your .profile and add that block.Take a look at your ~/.profile and see if there is block like:# set PATH so it includes user&#39;s private bin if it existsif [ -d &quot;$HOME/.local/bin&quot; ] ; then PATH=&quot;$HOME/.local/bin:$PATH&quot;fi" }, { "title": "Programming AVR in WSL Tips and Tricks", "url": "/posts/programming-avr-in-wsl-tips-and-tricks/", "categories": "Tutorial, AVR", "tags": "tutorial, avr, tips, permissions, udev", "date": "2022-05-20 11:00:00 -0700", "snippet": "#1. Fixing device permissionsSince systemd is not running under WSL2 some of the UDEV rules won’t run that set the groups, etc. As a result the devices under /dev/ will all be owned by root still.$ ls -al /dev/ttyACM*crw-rw---- 1 root root 166, 0 May 29 23:14 /dev/ttyACM0As a temporary fix…Run sudo system udev restart BEFORE plugging in the device (or attaching to WSL). This will ensure that UDEV can make the necessary adjustments. (change the group owner to plugdev)After the fix.$ ls -al /dev/ttyACM*crw-rw---- 1 root plugdev 166, 0 May 29 23:14 /dev/ttyACM0Also make sure your user is a member of plugdev. Run groups to checkMaking it automaticAdd this to ~/.bashrc[ -z &quot;$(pgrep systemd-udevd)&quot; ] &amp;amp;&amp;amp; sudo service udev restart &amp;amp;&amp;gt; /dev/nulladded in sudo visudo to allow .bashrc (or well anyone) to actually do it.).%sudo ALL=NOPASSWD: /usr/sbin/service udev restart #2. Force udev to fix permissions without unplugging the deviceThis seems to be enough get the ACLs set…If AFTER device already attached… re-trigger eventsudo service udev restartsudo udevadm trigger -v --name-match=ttyACM0If BEFORE device attached… this is sufficientsudo service udev restartAlternatively you could cycle the detach/attach cycle manually via usbipusbipd.exe wsl detach --hardware-id=2341:0001usbipd.exe wsl attach --hardware-id=2341:0001#3. Smart device attachmentAttach if not already attached[ -z &quot;$(usbipd.exe wsl list | grep 2341:0001.*Attached)&quot; ] &amp;amp;&amp;amp; usbipd.exe wsl attach --hardware-id=2341:0001OR grep can do the testing for us… slightly different semantics… if we find the device and it is not attached… The other test would try to attach even if the device wasn’t listed.usbipd.exe wsl list | grep -q &quot;2341:0001.*Not attached&quot; &amp;amp;&amp;amp; \\echo &quot;Attaching&quot; &amp;amp;&amp;amp; \\usbipd.exe wsl attach --hardware-id=2341:0001Crazy one-liner command check for device existence first, and then attach if not already attached.$ (usbipd.exe wsl list | grep -q &quot; 2341:0001 &quot; || (echo &quot;Device not found&quot;; false)) &amp;amp;&amp;amp; (usbipd.exe wsl list | grep -q &quot;2341:0001.*Not attached&quot; &amp;amp;&amp;amp; echo &quot;Device found, but not attached. Attaching...&quot; &amp;amp;&amp;amp; usbipd.exe wsl attach --hardware-id=2341:0001 || echo &quot;Device attached&quot;) Broken down… Check for device existence (usbipd.exe wsl list | grep -q &quot; 2341:0001 &quot; || (echo &quot;Device not found&quot;; false)) &amp;amp;&amp;amp; \\ Check if already attached (usbipd.exe wsl list | grep -q &quot;2341:0001.*Not attached&quot; &amp;amp;&amp;amp; \\ If not attached, attach echo &quot;Device found, but not attached. Attaching...&quot; &amp;amp;&amp;amp; \\usbipd.exe wsl attach --hardware-id=2341:0001 \\ Otherwise just report the device attached || echo &quot;Device attached&quot;) #4. WSL Make enhancementsWe can build the smart device attachment into a Makefile target and call it from your flash target automatically. Now you don’t have to worry about usbip at all.## WSL features#DEVICE_HWID = 2341:0001# Attach the device via usb/ip if not already attachedusbip_attach: @[ -z &quot;$(shell usbipd.exe wsl list | grep $(DEVICE_HWID).*Attached)&quot; ] \\ &amp;amp;&amp;amp; echo &quot;Device not attached. Attaching now...&quot; \\ &amp;amp;&amp;amp; usbipd.exe wsl attach --hardware-id=$(DEVICE_HWID) \\ &amp;amp;&amp;amp; sleep 2 \\ || true# Flash via windows-based avrdude.exeflash_win: AVRDUDE = /mnt/c/DEV/AVR/avrdude/avrdude.exeflash_win: PROGRAMMER_ARGS = -P COM4flash_win: flash" } ]
